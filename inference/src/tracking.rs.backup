/// Tracking method selection for video pipeline
use crate::frame_pipeline::TileDetection;
use crate::tracking_utils::{
    calculate_iou, tile_detection_to_tracker_format, tracker_output_to_tile_detection, BoundingBox,
};
use crossbeam::channel::{self, Receiver, Sender};
use ioutrack::{ByteMultiTracker, KalmanMultiTracker, MultiObjectTracker};
use rayon::prelude::*;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use tokio::runtime::Runtime;

/// Commands that can be sent to any tracking operator
#[derive(Debug)]
pub enum TrackingCommand {
    /// Update tracker with new detections
    Update {
        detections: Vec<TileDetection>,
        dt: f32,
    },
    /// Predict forward in time without detections
    Predict { dt: f32 },
    /// Shutdown the tracker thread
    Shutdown,
}

/// Available tracking algorithms
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum TrackingMethod {
    /// Kalman filter-based tracking with Hungarian data association
    Kalman,
    /// ByteTrack algorithm (more modern, handles occlusions better)
    ByteTrack,
}

impl Default for TrackingMethod {
    fn default() -> Self {
        Self::Kalman
    }
}

impl std::fmt::Display for TrackingMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Kalman => write!(f, "Kalman Filter"),
            Self::ByteTrack => write!(f, "ByteTrack"),
        }
    }
}

/// Configuration for tracking methods
#[derive(Debug, Clone)]
pub enum TrackingConfig {
    Kalman(crate::tracking_types::KalmanConfig),
    ByteTrack(crate::tracking_types::ByteTrackConfig),
}

impl Default for TrackingConfig {
    fn default() -> Self {
        Self::Kalman(crate::tracking_types::KalmanConfig::default())
    }
}

impl TrackingConfig {
    /// Get the tracking method from config
    pub fn method(&self) -> TrackingMethod {
        match self {
            Self::Kalman(_) => TrackingMethod::Kalman,
            Self::ByteTrack(_) => TrackingMethod::ByteTrack,
        }
    }
}

/// Unified tracker interface that can use any tracking algorithm with async processing
pub struct UnifiedTracker {
    /// Tracking method being used
    method: TrackingMethod,
    /// Command channel for async operations
    command_tx: Sender<TrackingCommand>,
    /// Cached predictions for fast synchronous access
    last_predictions: Arc<Mutex<Vec<TileDetection>>>,
    /// Background worker thread handle
    _worker_handle: Option<thread::JoinHandle<()>>,
    /// Tokio runtime for maintenance tasks
    _runtime: Runtime,
    /// Shutdown signal for cleanup
    shutdown_tx: Arc<Mutex<Option<tokio::sync::oneshot::Sender<()>>>>,
}

/// Metadata for each track
#[derive(Clone, Debug)]
struct TrackMetadata {
    class_id: u32,
    class_name: String,
    last_confidence: f32,
}

/// IoU matching result for batch processing
#[derive(Clone, Copy, Debug)]
struct IoUMatch {
    detection_idx: usize,
    track_id: u32,
    iou_score: f32,
}

impl std::fmt::Debug for UnifiedTracker {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("UnifiedTracker")
            .field("method", &self.method)
            .field("predictions_cached", &self.last_predictions.lock().unwrap().len())
            .finish_non_exhaustive()
    }
}

impl UnifiedTracker {
    /// Create new tracker from config with async processing
    pub fn new(config: TrackingConfig) -> Self {
        let (command_tx, command_rx) = channel::unbounded::<TrackingCommand>();
        let last_predictions = Arc::new(Mutex::new(Vec::new()));

        // Create the appropriate tracker based on config
        let (tracker, method): (Box<dyn MultiObjectTracker>, TrackingMethod) = match &config {
            TrackingConfig::Kalman(kalman_config) => {
                log::info!("Creating KalmanMultiTracker with config: max_age={}, min_hits={}, iou_threshold={:.3}, init_tracker_min_score={:.3}", 
                    kalman_config.max_age, kalman_config.min_hits, kalman_config.iou_threshold, kalman_config.init_tracker_min_score);
                let tracker = KalmanMultiTracker::new(
                    kalman_config.max_age,
                    kalman_config.min_hits,
                    kalman_config.iou_threshold,
                    kalman_config.init_tracker_min_score,
                    kalman_config.measurement_noise,
                    kalman_config.process_noise,
                );
                (Box::new(tracker), TrackingMethod::Kalman)
            }
            TrackingConfig::ByteTrack(bytetrack_config) => {
                log::info!("Creating ByteMultiTracker with config: max_age={}, min_hits={}, iou_threshold={:.3}, init_tracker_min_score={:.3}", 
                    bytetrack_config.max_age, bytetrack_config.min_hits, bytetrack_config.iou_threshold, bytetrack_config.init_tracker_min_score);
                let tracker = ByteMultiTracker::new(
                    bytetrack_config.max_age,
                    bytetrack_config.min_hits,
                    bytetrack_config.iou_threshold,
                    bytetrack_config.init_tracker_min_score,
                    bytetrack_config.high_score_threshold,
                    bytetrack_config.low_score_threshold,
                    bytetrack_config.measurement_noise,
                    bytetrack_config.process_noise,
                );
                (Box::new(tracker), TrackingMethod::ByteTrack)
            }
        };

        let tracker_arc = Arc::new(Mutex::new(tracker));
        let predictions_clone = Arc::clone(&last_predictions);
        
        // Create tokio runtime for maintenance
        let runtime = tokio::runtime::Builder::new_multi_thread()
            .worker_threads(1)
            .thread_name("unified-tracker-maintenance")
            .enable_all()
            .build()
            .expect("Failed to create UnifiedTracker maintenance runtime");

        // Spawn command processor thread
        let tracker_clone = Arc::clone(&tracker_arc);
        let worker_handle = thread::spawn(move || {
            Self::command_processor(tracker_clone, predictions_clone, command_rx);
        });

        // Spawn maintenance thread
        let (shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel();
        let tracker_clone = Arc::clone(&tracker_arc);
        runtime.spawn(async move {
            Self::maintenance_loop(tracker_clone, shutdown_rx).await;
        });

        Self {
            method,
            command_tx,
            last_predictions,
            _worker_handle: Some(worker_handle),
            _runtime: runtime,
            shutdown_tx: Arc::new(Mutex::new(Some(shutdown_tx))),
        }
    }

    /// Send update command (non-blocking)
    pub fn send_update(&self, detections: Vec<TileDetection>, dt: f32) -> Result<(), String> {
        self.command_tx
            .send(TrackingCommand::Update { detections, dt })
            .map_err(|e| format!("Failed to send update: {}", e))
    }

    /// Send predict command (non-blocking)  
    pub fn send_predict(&self, dt: f32) -> Result<(), String> {
        self.command_tx
            .send(TrackingCommand::Predict { dt })
            .map_err(|e| format!("Failed to send predict: {}", e))
    }

    /// Get cached predictions (synchronous, fast)
    pub fn get_predictions(&self) -> Vec<TileDetection> {
        self.last_predictions.lock().unwrap().clone()
    }

    /// Get tracking method
    pub fn method(&self) -> TrackingMethod {
        self.method
    }

    /// Update tracker with new detections
    pub fn update(&mut self, detections: &[TileDetection], _dt: f32) -> Vec<TileDetection> {
        self.update_count += 1;

        // For real detections (non-empty), purge tracks older than 1 frames
        /*if !detections.is_empty() {
            self.purge_old_tracks(1);
        }
        */

        if detections.is_empty() {
            log::debug!(
                "UnifiedTracker::update called with 0 detections (update #{})",
                self.update_count
            );

            // Age all tracks by 1 frame when no detections
            self.age_all_tracks();
            return Vec::new();
        }

        log::debug!(
            "UnifiedTracker::update called with {} detections (update #{})",
            detections.len(),
            self.update_count
        );

        // Fast path for single detection
        if detections.len() == 1 {
            return self.update_single_detection(&detections[0]);
        }

        // Convert TileDetection to tracker format
        let detection_array = tile_detection_to_tracker_format(detections);

        log::debug!(
            "Converted to tracker array with shape: {:?}",
            detection_array.shape()
        );

        // Validation of detections using static validation function
        let valid_count = detections
            .par_iter()
            .map(|det| is_detection_valid(det))
            .filter(|&is_valid| is_valid)
            .count();

        log::debug!("Valid detections: {}/{}", valid_count, detections.len());

        // Use unified interface
        match self.tracker.update(detection_array.view(), true, false) {
            Ok(tracks) => {
                log::debug!("Tracker returned {} tracks", tracks.nrows());

                if tracks.is_empty() {
                    log::warn!(
                        "Tracker returned empty tracks array despite {} valid input detections",
                        valid_count
                    );
                    return Vec::new();
                }

                // Convert back to TileDetection
                let mut tracked_detections = tracker_output_to_tile_detection(&tracks);

                // IoU matching for metadata assignment
                self.update_track_metadata(detections, &mut tracked_detections);

                // Update track ages based on active tracks
                let active_track_ids: Vec<u32> = tracked_detections
                    .iter()
                    .filter_map(|det| det.track_id)
                    .collect();
                self.update_track_ages(&active_track_ids);

                tracked_detections
            }
            Err(e) => {
                log::error!("Tracker update failed: {:?}", e);
                Vec::new()
            }
        }
    }

    /// Fast path for single detection update
    fn update_single_detection(&mut self, detection: &TileDetection) -> Vec<TileDetection> {
        if !is_detection_valid(detection) {
            return Vec::new();
        }

        // Create single-element array
        let detection_data = vec![
            detection.x,
            detection.y,
            detection.x + detection.w,
            detection.y + detection.h,
            detection.confidence,
        ];

        let detection_array = ndarray::Array2::from_shape_vec((1, 5), detection_data)
            .unwrap_or_else(|_| ndarray::Array2::zeros((0, 5)));

        match self.tracker.update(detection_array.view(), true, false) {
            Ok(tracks) => {
                let mut tracked_detections = tracker_output_to_tile_detection(&tracks);

                // Simple metadata update for single detection
                if let Some(tracked_det) = tracked_detections.first_mut() {
                    if let Some(track_id) = tracked_det.track_id {
                        self.track_metadata.insert(
                            track_id,
                            TrackMetadata {
                                class_id: detection.class_id,
                                class_name: detection.class_name.clone(),
                                last_confidence: detection.confidence,
                            },
                        );

                        tracked_det.class_id = detection.class_id;
                        tracked_det.class_name = detection.class_name.clone();
                        tracked_det.confidence = detection.confidence;

                        // Update track ages for single detection
                        self.update_track_ages(&[track_id]);
                    }
                }

                tracked_detections
            }
            Err(_) => Vec::new(),
        }
    }

    /// IoU matching and metadata update
    fn update_track_metadata(
        &mut self,
        detections: &[TileDetection],
        tracked_detections: &mut [TileDetection],
    ) {
        if detections.is_empty() || tracked_detections.is_empty() {
            return;
        }

        // Pre-compute bounding boxes for all detections and tracks
        let det_boxes: Vec<BoundingBox> = detections
            .par_iter()
            .map(|det| BoundingBox {
                x1: det.x,
                y1: det.y,
                x2: det.x + det.w,
                y2: det.y + det.h,
            })
            .collect();

        let track_boxes: Vec<(u32, BoundingBox)> = tracked_detections
            .par_iter()
            .filter_map(|tracked_det| {
                tracked_det.track_id.map(|id| {
                    (
                        id,
                        BoundingBox {
                            x1: tracked_det.x,
                            y1: tracked_det.y,
                            x2: tracked_det.x + tracked_det.w,
                            y2: tracked_det.y + tracked_det.h,
                        },
                    )
                })
            })
            .collect();

        // IoU computation
        self.temp_iou_results.clear();
        self.temp_iou_results
            .reserve(detections.len() * tracked_detections.len());

        let iou_results: Vec<IoUMatch> = det_boxes
            .par_iter()
            .enumerate()
            .flat_map(|(det_idx, det_box)| {
                track_boxes
                    .par_iter()
                    .filter_map(move |(track_id, track_box)| {
                        let iou = calculate_iou(det_box, track_box);
                        if iou > 0.3 {
                            Some(IoUMatch {
                                detection_idx: det_idx,
                                track_id: *track_id,
                                iou_score: iou,
                            })
                        } else {
                            None
                        }
                    })
            })
            .collect();

        // Find best matches using parallel grouping and reduction
        let best_matches: HashMap<u32, (usize, f32)> = iou_results
            .into_par_iter()
            .fold(HashMap::<u32, (usize, f32)>::new, |mut acc, iou_match| {
                let current_best = acc.get(&iou_match.track_id);
                if current_best.map_or(true, |(_, current_iou)| iou_match.iou_score > *current_iou)
                {
                    acc.insert(
                        iou_match.track_id,
                        (iou_match.detection_idx, iou_match.iou_score),
                    );
                }
                acc
            })
            .reduce(HashMap::<u32, (usize, f32)>::new, |mut acc1, acc2| {
                for (track_id, (det_idx, iou_score)) in acc2 {
                    let current_best = acc1.get(&track_id);
                    if current_best.map_or(true, |(_, current_iou)| iou_score > *current_iou) {
                        acc1.insert(track_id, (det_idx, iou_score));
                    }
                }
                acc1
            });

        // Update metadata based on best matches
        for (track_id, (det_idx, iou_score)) in best_matches {
            if let Some(detection) = detections.get(det_idx) {
                log::debug!(
                    "Detection {} matched to track {} with IoU={:.3}",
                    det_idx,
                    track_id,
                    iou_score
                );

                self.track_metadata.insert(
                    track_id,
                    TrackMetadata {
                        class_id: detection.class_id,
                        class_name: detection.class_name.clone(),
                        last_confidence: detection.confidence,
                    },
                );
            }
        }

        // Apply metadata to tracked detections
        for tracked_det in tracked_detections {
            if let Some(track_id) = tracked_det.track_id {
                if let Some(metadata) = self.track_metadata.get(&track_id) {
                    tracked_det.class_id = metadata.class_id;
                    tracked_det.class_name = metadata.class_name.clone();
                    tracked_det.confidence = metadata.last_confidence;
                }
            }
        }
    }

    /// Get number of active tracks
    pub fn num_tracks(&self) -> usize {
        self.tracker.num_tracklets()
    }

    /// Get tracking method
    pub fn method(&self) -> TrackingMethod {
        self.method
    }

    /// Command processor thread - handles tracker updates in background
    fn command_processor(
        tracker: Arc<Mutex<Box<dyn MultiObjectTracker>>>,
        last_predictions: Arc<Mutex<Vec<TileDetection>>>,
        command_rx: Receiver<TrackingCommand>,
    ) {
        log::info!("UnifiedTracker command processor started");
        let mut commands_processed = 0_u64;
        let mut track_metadata: HashMap<u32, TrackMetadata> = HashMap::with_capacity(64);

        loop {
            match command_rx.recv() {
                Ok(TrackingCommand::Update { detections, dt: _ }) => {
                    // Convert TileDetection to tracker format
                    let detection_array = tile_detection_to_tracker_format(&detections);

                    let mut tracker = tracker.lock().unwrap();
                    match tracker.update(detection_array.view(), true, false) {
                        Ok(tracks) => {
                            // Convert back to TileDetection format
                            let mut tracked_detections = tracker_output_to_tile_detection(&tracks);

                            // Update metadata for tracked detections
                            Self::update_track_metadata(&detections, &mut tracked_detections, &mut track_metadata);

                            commands_processed += 1;

                            // Store predictions for fast access
                            {
                                let mut predictions = last_predictions.lock().unwrap();
                                *predictions = tracked_detections;
                            }

                            if commands_processed % 100 == 0 {
                                log::debug!(
                                    "UnifiedTracker processed {} updates, {} active tracks",
                                    commands_processed,
                                    tracker.num_tracklets()
                                );
                            }
                        }
                        Err(e) => {
                            log::error!("UnifiedTracker update failed: {:?}", e);
                        }
                    }
                }
                Ok(TrackingCommand::Predict { dt: _ }) => {
                    // Get predictions from current tracker state
                    let tracker = tracker.lock().unwrap();
                    let empty_detections = ndarray::Array2::zeros((0, 5));
                    
                    match tracker.update(empty_detections.view(), true, false) {
                        Ok(tracks) => {
                            let mut predictions = tracker_output_to_tile_detection(&tracks);

                            // Apply metadata to predictions
                            for prediction in &mut predictions {
                                if let Some(track_id) = prediction.track_id {
                                    if let Some(metadata) = track_metadata.get(&track_id) {
                                        prediction.class_id = metadata.class_id;
                                        prediction.class_name = metadata.class_name.clone();
                                        prediction.confidence = metadata.last_confidence;
                                    }
                                }
                            }

                            // Store predictions
                            {
                                let mut cached_predictions = last_predictions.lock().unwrap();
                                *cached_predictions = predictions;
                            }
                        }
                        Err(e) => {
                            log::error!("UnifiedTracker prediction failed: {:?}", e);
                        }
                    }

                    commands_processed += 1;
                }
                Ok(TrackingCommand::Shutdown) => {
                    log::info!(
                        "UnifiedTracker shutting down after {} commands",
                        commands_processed
                    );
                    break;
                }
                Err(_) => {
                    log::warn!("UnifiedTracker command channel disconnected");
                    break;
                }
            }
        }

        log::info!("UnifiedTracker command processor stopped");
    }

    /// Maintenance loop - periodic cleanup and logging
    async fn maintenance_loop(
        tracker: Arc<Mutex<Box<dyn MultiObjectTracker>>>,
        mut shutdown_rx: tokio::sync::oneshot::Receiver<()>,
    ) {
        log::info!("UnifiedTracker maintenance thread started (checking every 100ms)");

        let mut interval = tokio::time::interval(Duration::from_millis(100));
        let mut maintenance_cycles = 0_u64;

        loop {
            tokio::select! {
                _ = interval.tick() => {
                    maintenance_cycles += 1;

                    // Get current tracker stats
                    let track_count = {
                        let tracker = tracker.lock().unwrap();
                        tracker.num_tracklets()
                    };

                    // Periodic status log
                    if maintenance_cycles % 100 == 0 {
                        log::debug!(
                            "UnifiedTracker maintenance: {} cycles, {} active tracks",
                            maintenance_cycles,
                            track_count
                        );
                    }
                }
                _ = &mut shutdown_rx => {
                    log::info!("UnifiedTracker maintenance received shutdown signal");
                    break;
                }
            }
        }

        log::info!("UnifiedTracker maintenance thread stopped");
    }

    /// Update track metadata for tracked detections
    fn update_track_metadata(
        detections: &[TileDetection],
        tracked_detections: &mut [TileDetection],
        track_metadata: &mut HashMap<u32, TrackMetadata>,
    ) {
        if detections.is_empty() || tracked_detections.is_empty() {
            return;
        }

        // Simple IoU matching for metadata assignment
        for tracked_det in tracked_detections.iter_mut() {
            if let Some(track_id) = tracked_det.track_id {
                // Find best matching detection
                let mut best_match = None;
                let mut best_iou = 0.3; // Minimum IoU threshold

                for (det_idx, detection) in detections.iter().enumerate() {
                    let det_box = BoundingBox {
                        x1: detection.x,
                        y1: detection.y,
                        x2: detection.x + detection.w,
                        y2: detection.y + detection.h,
                    };

                    let track_box = BoundingBox {
                        x1: tracked_det.x,
                        y1: tracked_det.y,
                        x2: tracked_det.x + tracked_det.w,
                        y2: tracked_det.y + tracked_det.h,
                    };

                    let iou = calculate_iou(&det_box, &track_box);
                    if iou > best_iou {
                        best_iou = iou;
                        best_match = Some(det_idx);
                    }
                }

                // Update metadata if we found a good match
                if let Some(det_idx) = best_match {
                    if let Some(detection) = detections.get(det_idx) {
                        let metadata = TrackMetadata {
                            class_id: detection.class_id,
                            class_name: detection.class_name.clone(),
                            last_confidence: detection.confidence,
                        };

                        track_metadata.insert(track_id, metadata.clone());

                        // Apply metadata to tracked detection
                        tracked_det.class_id = metadata.class_id;
                        tracked_det.class_name = metadata.class_name;
                        tracked_det.confidence = metadata.last_confidence;
                    }
                }
            }
        }
    }
}

/// Static detection validation function
#[inline]
fn is_detection_valid(detection: &TileDetection) -> bool {
    detection.x.is_finite()
        && detection.y.is_finite()
        && detection.w.is_finite()
        && detection.h.is_finite()
        && detection.confidence.is_finite()
        && detection.x >= 0.0
        && detection.y >= 0.0
        && detection.w > 0.0
        && detection.h > 0.0
        && detection.confidence >= 0.0
        && detection.confidence <= 1.0
}
            .track_ages
            .par_iter()
            .map(|(&track_id, &age)| (track_id, age + 1))
            .collect();

        self.track_ages = updated_ages;
    }

    /// Update track ages based on current active tracks
    fn update_track_ages(&mut self, active_track_ids: &[u32]) {
        // Parallel aging of all tracks by 1 frame
        let mut updated_ages: HashMap<u32, u32> = self
            .track_ages
            .par_iter()
            .map(|(&track_id, &age)| (track_id, age + 1))
            .collect();

        // Sequential update for matched tracks (HashMap mutation not thread-safe)
        for &track_id in active_track_ids {
            updated_ages.insert(track_id, 0);
        }

        // Parallel filtering to keep only existing tracks
        let existing_track_ids: std::collections::HashSet<u32> =
            active_track_ids.par_iter().copied().collect();

        let filtered_ages: HashMap<u32, u32> = updated_ages
            .par_iter()
            .filter_map(|(&track_id, &age)| {
                if existing_track_ids.contains(&track_id) {
                    Some((track_id, age))
                } else {
                    None
                }
            })
            .collect();

        self.track_ages = filtered_ages;
    }
}

/// Static detection validation function
#[inline]
fn is_detection_valid(detection: &TileDetection) -> bool {
    detection.x.is_finite()
        && detection.y.is_finite()
        && detection.w.is_finite()
        && detection.h.is_finite()
        && detection.confidence.is_finite()
        && detection.x >= 0.0
        && detection.y >= 0.0
        && detection.w > 0.0
        && detection.h > 0.0
        && detection.confidence >= 0.0
        && detection.confidence <= 1.0
}
